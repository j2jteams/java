## 📘 Method Overloading vs Method Overriding

### 🔁 Method Overloading
Having multiple methods with the same name but **different parameters** (type/number/order).

```java
class Calculator {
    int add(int a, int b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
    double add(double a, double b) { return a + b; }
}
```

🧠 **Why use it?**
- It is a direct implementation of **compile-time polymorphism**.
- Keeps the code **cohesive** by logically grouping related operations under one method name.
- Improves **readability and usability** — clients don’t have to remember different method names.
- Enables **type-safe flexibility** for different argument combinations.

> ✅ Overloading enhances flexibility and maintains a clean API without sacrificing type safety — a must for robust method design.

---

### 🔄 Method Overriding
Subclass provides a **new implementation** of a method inherited from its superclass.

```java
class Animal {
    void sound() {
        System.out.println("Generic sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}
```

🧠 **Why use it?**
- It is the foundation of **runtime polymorphism** — actual method execution depends on the object type.
- Enables subclasses to **customize behavior** while keeping the interface consistent.
- Supports **extensibility** — you can introduce new behaviors in derived classes without touching base code.
- Aligns with the **Liskov Substitution Principle**, promoting interchangeable components.

> ✅ Overriding allows dynamic behavior changes, making code more adaptable and maintainable in large-scale systems.

---

Would you like me to move to the next core Java topic? Options:
- Access Modifiers
- Static Keyword
- Interfaces and Abstract Classes
- Final Keyword
