📘 Topic 4: Constructors and the this Keyword

🔨 What is a Constructor?

A constructor is a special method that gets called when an object is created. It initializes the object.

class Car {
    String brand;

    Car() {
        brand = "Tesla";
    }
}

🔄 Parameterized Constructor + this

class Car {
    String brand;

    Car(String brand) {
        this.brand = brand; // Refers to current object's field
    }
}

🧠 Why use constructors and this?

Constructors allow you to initialize your objects immediately.

Overloading constructors gives flexibility for different ways to create objects.

this keyword clarifies scope and allows calling other constructors or methods inside the class.

Encourages DRY principles by reusing constructor logic (this()).

✅ Constructors are essential for proper object lifecycle, and this empowers you to manage internal state unambiguously.

📘 Topic 5: Method Overloading vs Method Overriding

🔁 Method Overloading

Having multiple methods with the same name but different parameters (type/number/order).

class Calculator {
    int add(int a, int b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
    double add(double a, double b) { return a + b; }
}

🧠 Why use it?

It’s a practical implementation of compile-time polymorphism.

Keeps code cohesive by grouping similar behaviors under one method name.

Makes your API easier to use and less error-prone.

Helps enforce method-level flexibility and adaptability to multiple inputs.

🔄 Method Overriding

Subclass provides a new implementation of a superclass method.

class Animal {
    void sound() { System.out.println("Generic sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Bark"); }
}

🧠 Why use it?

Enables runtime polymorphism (dynamic method dispatch).

Allows child classes to customize inherited behavior.

Supports extensibility and maintainability — key principles of OOP.

Core to the Liskov Substitution Principle — treating derived types as base types safely.

